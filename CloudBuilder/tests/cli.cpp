//
//  cli.cpp
//  CloudBuilderMacOSX
//
//  Created by roland on 03/05/13.
//
//

#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#pragma GCC diagnostic ignored "-Wlocal-type-template-args"

const char *loremipsum = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce elementum metus in malesuada ultrices. Morbi viverra, erat in feugiat posuere, dui nisl tempus quam, nec maximus tellus massa vel leo. Aenean ac augue sit amet massa luctus sagittis. Praesent nec vestibulum lacus. Cras rutrum finibus orci, aliquet laoreet lorem porttitor euismod. Praesent eu risus a arcu luctus sagittis vitae a urna. Suspendisse pellentesque est id erat mattis, et dignissim tellus maximus. Mauris tempus nisl sit amet ornare porta. Phasellus tincidunt eros placerat ante congue, volutpat imperdiet velit auctor. Suspendisse congue viverra fermentum. Ut suscipit interdum eros, et porttitor risus tristique in. Ut placerat ultrices posuere. Donec euismod quam sapien, sed ultricies metus congue vitae. Curabitur id venenatis eros, at gravida tortor. Praesent dignissim ligula sit amet rutrum fermentum.Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Aliquam dolor magna, porta in tincidunt ut, tempor a lorem. Interdum et malesuada fames ac ante ipsum primis in faucibus. Sed sit amet consectetur ligula. Aliquam a metus a metus fermentum pellentesque. Proin malesuada, dolor eget dapibus gravida, dui risus aliquet eros, quis rhoncus leo mi sed erat. Nulla augue ex, fermentum in nibh vel, tempus dignissim arcu. Donec urna arcu, aliquet quis bibendum quis, porttitor vel metus. Vestibulum luctus ultrices mi, in fermentum enim consequat nec. Sed pretium diam id quam interdum cursus. Nulla semper pulvinar lectus id dapibus. Integer mattis cursus nisl, vitae mollis risus placerat non. Donec sed ex venenatis arcu rutrum auctor nec quis diam. Vestibulum faucibus dui ut ex lobortis pulvinar.Vestibulum vitae feugiat nulla. Proin ac malesuada ex. Nam aliquet dignissim tortor id luctus. Morbi facilisis scelerisque enim bibendum fringilla. Vestibulum accumsan neque interdum euismod commodo. Sed pharetra fermentum gravida. Cras eleifend lectus urna, facilisis pretium lorem dictum vel. In finibus "
	"tempor lectus sit amet pulvinar. Pellentesque a metus erat. Quisque vehicula vel turpis ut fermentum. Aenean quis sagittis purus, vel rhoncus odio. In enim nisi, laoreet eu dui eu, ornare cursus lorem. Donec eget turpis aliquet, faucibus ligula in, pharetra mauris.Proin dui leo, sodales fermentum nibh vitae, lacinia vulputate dui. Etiam lobortis augue eget sapien rhoncus elementum. Suspendisse nec pharetra urna. Etiam vel efficitur metus, non tempor ipsum. Vestibulum a laoreet erat. Integer nisi arcu, dapibus eget elit vitae, laoreet iaculis elit. Phasellus in vestibulum purus. Nullam varius sed sapien sed luctus. Praesent eu maximus mi, at laoreet elit. Sed lacinia faucibus dui, vitae imperdiet ex lacinia in. Sed pulvinar at dui in tempor. Proin dapibus massa in erat volutpat, in sodales lacus condimentum.Nunc placerat vitae purus id sodales. Nam non dapibus odio. Donec massa purus, tincidunt vel sapien nec, pulvinar aliquam nibh. Duis in elementum sapien. Donec maximus nulla eu cursus venenatis. Nullam condimentum nisl sit amet purus tempus, at fringilla metus mattis. Nulla commodo consectetur odio nec placerat. Donec purus mauris, interdum eget quam et, rhoncus egestas sapien. Ut posuere dolor nisi, in maximus quam tincidunt ac. Quisque lobortis suscipit consectetur.Sed venenatis enim ac fermentum aliquet. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque elementum sapien vel sem mattis dignissim. In hac habitasse platea dictumst. Donec vestibulum mi vel velit ultrices, semper gravida nibh pretium. Praesent faucibus laoreet odio nec commodo. In lobortis eu odio eu tincidunt. Nullam tempus vehicula dolor, id tristique justo vestibulum sit amet. Donec mollis magna a urna scelerisque ornare.Sed in odio ut purus sodales ullamcorper. Donec iaculis lectus in vehicula varius. Praesent et bibendum mauris. Mauris at ultricies magna. Donec sed dolor porta, molestie ipsum non, feugiat massa. Ut in urna sit amet sem luctus malesuada id id nunc. Aenean semper ipsum dui, ultrices tincidunt nulla mollis "
	"in. Cras ut congue est. Donec sit amet odio iaculis nunc faucibus mollis in in elit. Vivamus ligula est, ultricies varius semper a, consectetur non erat. Integer in hendrerit massa. Etiam ultricies pellentesque felis, mollis placerat quam bibendum ac. Nam ullamcorper mollis mi id consequat.Mauris lectus leo, scelerisque at blandit sed, consectetur et nisi. Donec pellentesque nibh et porttitor lobortis. Vivamus non nunc et est eleifend rhoncus. Vestibulum et turpis sit amet massa dictum hendrerit at in arcu. Duis vel auctor nibh. Praesent magna ante, ornare quis tincidunt et, mattis eu ex. Aliquam non vehicula ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed rutrum risus dapibus, sollicitudin eros id, mattis ipsum. Vivamus mauris sapien, luctus et ultrices auctor, tempus at tortor. Nunc ut tortor eleifend, rhoncus nisl in, volutpat nibh. Quisque id odio volutpat, sodales orci eget, iaculis lectus. Donec dignissim ullamcorper ex accumsan facilisis.Suspendisse in nunc sit amet nunc egestas suscipit eu nec erat. Curabitur mollis, dui nec sagittis consectetur, lorem neque ultrices tellus, a viverra eros lorem eget sapien. Nulla est ipsum, rhoncus at ex ut, sagittis sagittis augue. Vivamus orci est, aliquam id dolor at, congue sagittis quam. Phasellus ac lectus dolor. Nulla at consequat neque, a pellentesque urna. Duis ut erat quis libero congue eleifend.Vivamus ultrices in turpis sed blandit. Integer egestas, ligula non dignissim lacinia, dolor magna aliquam quam, quis euismod orci est id lacus. Maecenas in augue sit amet augue sollicitudin tempus nec eu ante. Vestibulum ac vehicula mi. Vestibulum at efficitur ex. Pellentesque ornare elit non tortor molestie, ut venenatis urna lobortis. Sed eget ante nec nibh suscipit ultrices. Phasellus purus diam, feugiat ac metus eget, pellentesque mattis quam. Etiam vel ipsum lorem. Nullam congue neque pulvinar ante facilisis, nec pharetra nunc lobortis. Quisque vulputate nulla at urna sagittis, a mollis neque condimentum. Cras vel venenatis ex. Duis velit "
	"velit, tristique at ex at, tempor varius magna. Praesent pretium risus a cursus cursus.Cras accumsan ultricies arcu ac varius. Quisque hendrerit est sit amet placerat rutrum. Mauris at bibendum risus. Nunc in tellus feugiat diam ullamcorper blandit. Nunc faucibus volutpat nisl ut sagittis. Maecenas auctor quis ligula condimentum fringilla. Suspendisse consequat, arcu eu tincidunt viverra, enim nulla auctor felis, eu porta enim ex at orci. Nulla facilisi. Phasellus lacinia diam id mi tincidunt efficitur. Fusce rutrum justo quis libero egestas varius. Curabitur vestibulum risus eget turpis vulputate, at consectetur est volutpat. Suspendisse potenti.Duis dictum dui sed nisl auctor aliquam. Ut et dui nisi. Phasellus vel dolor faucibus, ornare eros a, sodales velit. Mauris ac tellus auctor, sollicitudin enim non, rhoncus purus. Ut tempor bibendum elementum. Maecenas at arcu et eros auctor ultrices. Etiam placerat malesuada purus nec faucibus.Nam elementum massa sit amet nisl condimentum, in sollicitudin purus condimentum. Morbi tincidunt lectus a mattis pretium. Quisque et magna quam. Phasellus at lacinia felis. Pellentesque sit amet quam eget diam maximus mattis quis vel sapien. Nulla egestas sit amet tortor ut placerat. Curabitur vel accumsan augue, vel faucibus metus. Nunc commodo consequat placerat. Donec quis porta magna. Aenean vestibulum turpis id aliquet hendrerit. Mauris vulputate ultricies venenatis.Suspendisse gravida ornare mollis. Vestibulum vestibulum erat ligula, volutpat vehicula sem mollis in. Donec laoreet odio eu est lacinia lobortis. Integer elementum nulla imperdiet tellus molestie, a efficitur lectus malesuada. Aenean sapien quam, mattis nec luctus et, volutpat sit amet magna. Aenean cursus finibus orci. Integer a pulvinar libero. Donec purus quam, facilisis maximus urna at, congue tincidunt velit. Maecenas facilisis elit et leo placerat interdum. Aenean dapibus commodo iaculis. Nunc ornare turpis nec elit malesuada, id tincidunt ante placerat. Cras a metus iaculis, pellentesque metus nec, "
	"gravida sapien. Aliquam erat volutpat. Cras scelerisque et elit eget tincidunt. Mauris et mattis est, in suscipit quam.Aliquam erat volutpat. Nullam at ligula nec augue consectetur auctor placerat efficitur erat. Mauris eget venenatis arcu, eu viverra diam. Pellentesque dignissim nisl faucibus odio maximus convallis. Maecenas ac dictum ipsum. Suspendisse quis elementum libero. Praesent in malesuada nisl.Etiam tortor neque, placerat et consectetur egestas, porttitor sit amet nibh. Integer commodo egestas leo, a convallis mauris tincidunt eget. Morbi ac sollicitudin purus, a fermentum lectus. Duis quis volutpat neque. Morbi vel sapien laoreet, maximus odio et, lobortis ligula. Proin tincidunt dolor lacus, et elementum lacus condimentum eget. Vestibulum viverra pretium nunc, sit amet rutrum nunc. Phasellus molestie libero eget posuere interdum. Vestibulum tempus venenatis luctus. Maecenas malesuada est lectus. Vestibulum non sollicitudin sem, nec rhoncus leo. Ut et lectus luctus dolor bibendum molestie. In hac habitasse platea dictumst.Curabitur pellentesque sem quis pulvinar cursus. Etiam non molestie nulla. Nunc ut nisi laoreet, accumsan ex gravida, tristique diam. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Donec vitae sodales metus, at vestibulum quam. Cras vel mattis neque. Nunc consectetur leo ante, at finibus ligula sodales ac. Nulla semper magna urna, at volutpat quam auctor id. Aliquam erat volutpat.Nullam sit amet pulvinar purus. Donec turpis nisi, iaculis eu enim ac, fringilla vehicula magna. Aenean lacinia tincidunt augue id accumsan. Duis convallis neque ornare lacus varius, sed imperdiet ex ultrices. Suspendisse potenti. Maecenas fermentum in risus a pulvinar. Sed efficitur metus id augue pulvinar iaculis. Nullam et egestas purus, quis vulputate ligula. Donec pulvinar vehicula gravida. Ut a vestibulum diam.In porta iaculis tellus, eget blandit urna elementum et. Ut vitae consectetur elit. Morbi diam leo, pellentesque non sodales non, porttitor ut "
	"ante. Mauris cursus, mi id vulputate rutrum, justo lectus faucibus odio, nec fringilla ex leo non lorem. Etiam et finibus eros. Sed in nulla interdum, vehicula risus a, elementum purus. Quisque euismod orci vel porta viverra. Sed et facilisis eros. Morbi feugiat sapien ex, sit amet consectetur nulla aliquet ac. Duis quis eros vitae mi posuere lobortis sed nec metus. Duis feugiat ultricies lectus, hendrerit consequat tellus maximus vitae.Aenean dolor lacus, convallis vel erat vitae, sollicitudin eleifend erat. Aliquam porttitor felis sapien, sed posuere diam rutrum non. Donec accumsan dapibus molestie. Integer ullamcorper vehicula consectetur. Aenean eu iaculis nulla, ut fringilla lacus. Nullam tempus gravida neque, eu iaculis est dignissim id. Cras sed libero a enim eleifend dictum. Vivamus volutpat iaculis ligula in mattis. Vestibulum at tortor sit amet turpis ultrices ornare. Fusce malesuada dolor vitae tellus sodales semper. Nullam sodales arcu enim, quis fermentum urna vehicula et. Suspendisse lacinia mi eu libero fermentum, vel egestas purus aliquet. Morbi tristique scelerisque nisl, et pulvinar diam finibus et.Vivamus iaculis ante quis massa mattis sollicitudin. Donec sagittis ornare lectus, ut laoreet est. Maecenas mollis fermentum ante, vel tincidunt turpis lacinia quis. Mauris porttitor, massa vel efficitur hendrerit, nulla ligula auctor neque, vitae scelerisque mauris massa eu tellus. Donec non quam nisi. Etiam fermentum elit mi, nec porttitor nisi imperdiet in. Duis non lorem eu nisl cursus dignissim. Cras porttitor massa tortor, rutrum ultrices ante ultricies vel. Cras aliquam ex at pellentesque imperdiet.Donec eget lectus eget nulla finibus venenatis id vitae leo. Vivamus non sem blandit, sollicitudin mauris id, convallis massa. Pellentesque volutpat mi ante, a mattis nibh luctus non. Maecenas finibus mauris dui, sed bibendum ante pretium et. Integer lobortis lectus et mi vestibulum fringilla. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Mauris "
	"vitae lacinia est. Donec et mollis tellus, non finibus metus. Nam non mollis arcu, eu euismod ipsum. Nullam viverra eros felis, quis faucibus turpis pharetra sed. Vivamus non tristique diam. Etiam ut euismod mi, et rhoncus tellus. Phasellus suscipit velit sed eleifend faucibus.Mauris semper odio felis, eget elementum sapien ullamcorper non. Fusce porta sit amet leo eu luctus. Aliquam rhoncus justo sit amet porta bibendum. Integer laoreet semper sapien, non feugiat erat laoreet non. Praesent tempus eros eros. Sed ex massa, ultricies at lacus eu, interdum aliquet eros. Mauris convallis congue mattis. Cras dolor metus, euismod vel consequat eget, vulputate ac est. Praesent felis sem, elementum vulputate volutpat eu, aliquet non urna. Nullam et maximus tortor, sed rhoncus purus. Mauris nec rhoncus sapien. Fusce augue urna, gravida at neque eget, mollis feugiat ligula. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque ut mattis leo. Maecenas tempor ut orci et egestas. Aenean facilisis sit amet urna vitae bibendum.Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur in purus non tellus vehicula tincidunt. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Pellentesque accumsan ligula vel placerat scelerisque. Aenean vulputate felis at leo egestas placerat. Duis tincidunt vulputate risus, at scelerisque sem tincidunt vitae. Nulla ultrices ipsum a leo sollicitudin iaculis. Duis ante justo, rhoncus nec sodales vel, luctus vitae risus. Nam lobortis ornare ipsum, eget dignissim lorem malesuada sit amet. Fusce sed augue vitae orci porta molestie sit amet et sapien.Pellentesque vehicula suscipit nibh, ac tincidunt nunc pellentesque ut. Etiam auctor est et magna sagittis, ac ultricies neque luctus. Donec congue quam tempor sodales tincidunt. Pellentesque pretium porttitor eros ut venenatis. Aliquam lorem nunc, posuere at efficitur a, malesuada vitae diam. In ornare dui volutpat euismod iaculis. Nulla dapibus ante metus, non tincidunt eros "
	"tincidunt vitae. Proin viverra in ante ut cursus. Nam at scelerisque nulla. Vestibulum vitae semper neque, quis bibendum orci. Morbi commodo nisi id euismod dignissim. Morbi pretium condimentum augue ac maximus.Mauris blandit sagittis eros vel placerat. Proin in nunc turpis. Donec suscipit orci sit amet lacus volutpat, nec vulputate dolor molestie. In hac habitasse platea dictumst. Curabitur tincidunt, augue sit amet porta suscipit, tortor sem sodales odio, quis pulvinar turpis ante ultrices eros. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Quisque orci magna, ultricies eget suscipit a, sodales quis augue. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam quis aliquet mi. Vivamus gravida nulla eget tortor convallis pharetra. Pellentesque placerat libero metus, vitae tincidunt felis consectetur consectetur. Fusce nec imperdiet nisi.Aliquam vel sapien risus. Proin volutpat efficitur lectus. Nullam at imperdiet nisi. Suspendisse diam turpis, faucibus at erat eget, suscipit venenatis lacus. Suspendisse non mollis massa. Phasellus at consequat quam. Phasellus non ipsum condimentum, tempus purus sit amet, mollis ipsum. Mauris dapibus risus eu felis tristique, quis tincidunt augue euismod. Proin viverra bibendum metus, quis faucibus ex lacinia finibus. Etiam est elit, eleifend quis semper a, blandit vel velit.Curabitur sed mollis risus. Maecenas eget lorem sit amet sem varius pretium accumsan vel augue. Praesent rutrum dapibus nisi. Aenean rhoncus ante ligula, pulvinar efficitur lectus accumsan eu. Curabitur eu lacus ipsum. Suspendisse potenti. Nullam fermentum elementum leo, et vestibulum lorem auctor vel. Donec non nibh non velit viverra auctor. Nullam sapien ante, interdum at faucibus at, sollicitudin at eros. Phasellus aliquet nisl nisl, sit amet consectetur ex luctus luctus. Aenean malesuada id ex ut accumsan. Cum sociis natoque penatibus et magnis dis parturient "
	"montes, nascetur ridiculus mus. Integer quam diam, condimentum sit amet augue pharetra, consequat cursus orci. Cras varius sapien viverra, venenatis mi eleifend, tristique ex. In nec congue nunc.Sed non purus odio. Praesent sit amet est a ante maximus tempor eu sit amet magna. Aliquam dolor sapien, fermentum sit amet convallis sed, commodo et erat. Ut id eros lacus. Vestibulum porta scelerisque est, non pretium ipsum. Vestibulum pellentesque diam odio, a pellentesque dolor bibendum at. Morbi lorem nisi, faucibus sit amet vulputate ut, sollicitudin ut lorem. Duis accumsan ipsum non lacus mattis gravida. Vestibulum at lectus nisl. Vestibulum nec ante et dolor consequat venenatis. Donec a sem eu ex aliquam rutrum eu sit amet arcu. In tortor augue, cursus at ante a, consequat ultrices felis. Pellentesque pharetra lorem id aliquam porta. Praesent vitae mattis ipsum. Aenean id ante vulputate, iaculis purus non, bibendum lacus. Vivamus sagittis sit amet velit sed consectetur.Morbi elit nunc, mollis quis tortor a, bibendum rutrum magna. Aliquam nec commodo sapien, sollicitudin scelerisque mauris. Praesent mattis commodo lacinia. Phasellus sit amet lectus lobortis quam varius volutpat suscipit id quam. Sed molestie orci at risus venenatis dictum. Vestibulum tortor diam, dapibus et posuere vitae, consequat vitae neque. Fusce fringilla sem sed augue congue imperdiet. Maecenas a elementum ante, at molestie urna. In non odio quis eros cursus convallis. Curabitur ut neque sed tellus mattis luctus quis id sapien. Vestibulum at arcu ac nisi ornare fermentum. Nunc viverra nisi eget velit ornare, vitae dictum leo vehicula. Curabitur vulputate eros nulla, quis tempor sem lobortis vitae. Suspendisse tincidunt orci eget nibh varius, eget aliquam est interdum. Aliquam luctus, quam vel rutrum volutpat, mi ex mattis ex, id consequat leo neque vel libero. Duis et lacus tellus.Maecenas hendrerit risus at arcu tempor semper pulvinar et neque. In a orci ac tellus ullamcorper dictum eu sed diam. Nullam et urna quis libero rutrum "
	"consequat dapibus ac tellus. Nullam imperdiet rhoncus fringilla. Morbi aliquet ex quam, sed fermentum nisi sodales vitae. Ut ac pretium eros. Morbi egestas, justo sit amet porta varius, ligula augue tempus nisi, id cursus purus dolor ac velit.Suspendisse at accumsan enim, vitae porta neque. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Ut mauris erat, pellentesque et nibh nec, laoreet vestibulum enim. Phasellus eget laoreet nibh, sed tincidunt ante. Cras non felis et nunc interdum iaculis vitae volutpat nisl. Maecenas orci orci, sagittis et vestibulum vitae, varius sed nibh. Nunc commodo augue id odio tristique facilisis.Praesent sit amet dictum tortor. Nullam rutrum finibus tortor, quis venenatis felis scelerisque vitae. Aliquam quis nibh mauris. Sed congue velit id mauris venenatis, ut tincidunt orci iaculis. Mauris semper euismod dolor non elementum. Nam vestibulum interdum velit id molestie. Proin condimentum nulla eu urna molestie, vel mattis dui malesuada. Integer diam eros, tempor a tempus consectetur, tincidunt a quam. Nullam non nunc sapien. Sed euismod finibus leo quis scelerisque.Nullam eget luctus ligula. Vestibulum vestibulum lectus turpis, sit amet auctor ipsum ultricies at. Etiam varius maximus ex, nec lobortis ligula rutrum nec. Praesent eu urna posuere, consequat mi non, gravida lacus. Sed ut fermentum turpis, sed porta mi. Pellentesque ut orci dictum, consectetur magna vel, fermentum nulla. Etiam lacinia arcu eget ex sollicitudin maximus. Praesent a sollicitudin magna. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec est nisi amet.";


#include <stdio.h>
#include <cstdlib>
#include <string.h>
#ifdef _WIN32
 #include   <windows.h>
 #include   <StrSafe.h>
 #include   <direct.h>
 #include   <io.h>
 #define snprintf _snprintf
#else
 #include <dirent.h>
 #include <unistd.h>
#endif

#include "cli.h"
#include "CotCHelpers.h"

#ifdef __ANDROID__
#include <android/log.h>
#define OUTPUT(...) __android_log_print(ANDROID_LOG_VERBOSE, "AndroidCLI", __VA_ARGS__)
#else
#define OUTPUT(...) printf (__VA_ARGS__)
#endif

#include <sys/time.h>
#include <map>
#include <string>

using std::map;
using std::string;
using namespace CloudBuilder;

// Hidden functionality
namespace CloudBuilder {
	extern FACTORY_FCT void CUserManager_ResetAchievements(const char *domain, CResultHandler *handler);
}

CLI *gCLI = NULL;

#define DELIMITERS "\"'.:{} )("

#define console(...) { \
	int len = snprintf(NULL, 0, __VA_ARGS__); \
	char *text = (char *) malloc(len+1); \
	sprintf(text, __VA_ARGS__); \
	gCLI->logger(text); \
	free(text); \
}

#define consoleJson(t, j) console("%s : %s", t, j ? j->printFormatted().c_str() : "null");

#define EQL(a,b) strcmp(argv[a],b)==0
#define JSON(a) CHJSON::parse(argv[a])
#define ISTRUE(a) ((argc>a && argv[a]) && (argv[a][0] == 'Y' || argv[a][0] == 'y'  || argv[a][0] == '1' || strcmp(argv[a],"true")==0))

typedef struct method {
	const char *name;
	const char *help;
	int min, max;
	void (MyClan::*call)(int argc, const char **argv);
} method;

#define ADD(X, min, max, help) \
	{ #X, help, min, max, \
	 &MyClan::X},

int gFavcount = 0;
const char * gFav[100];

void initFav()
{
	gFav[gFavcount++] = "setup cloudbuilder local";
	gFav[gFavcount++] = "setup cloudbuilder dev";
	gFav[gFavcount++] = "setup cloudbuilder vagrant";
	gFav[gFavcount++] = "setup cloudbuilder sandbox";
	gFav[gFavcount++] = "setup cloudbuilder local-parallels";
	gFav[gFavcount++] = "setup cloudbuilder temp";
	gFav[gFavcount++] = "setup cloudbuilder prod";
	gFav[gFavcount++] = "resumesession &gamer_id &gamer_secret";
	gFav[gFavcount++] = "resumesession &friend_id &friend_secret";
	gFav[gFavcount++] = "script release";
	gFav[gFavcount++] = "script florian";
	gFav[gFavcount++] = "setup testgame sandbox";
}

static char *strstr_delimiter(const char*string, const char*token, const char*delimiters) {
	char *p = (char*) strstr(string, token);

	if (p==NULL) return NULL;

	char endingdcar = *(p+strlen(token));

	if (endingdcar == 0 || strchr(delimiters, endingdcar)!=0) return p;

	return NULL;
}

static char* str_replace(const char *strbuf, const char *strold, const char *strnew, const char *delimiters) {
	char *strret, *p = NULL;
	char *posnews, *posold;
	size_t szold = strlen(strold);
	size_t sznew = strlen(strnew);
	size_t n = 1;

	if(!strbuf)
		return NULL;
	if(!strold || !strnew || !(p = (char*) strstr_delimiter(strbuf, strold, delimiters)))
		return strdup(strbuf);

	while(n > 0) {
		if(!(p = strstr_delimiter(p+1, strold, delimiters)))
			break;
		n++;
	}

	strret = (char*)malloc(strlen(strbuf)-(n*szold)+(n*sznew)+1);

	p = (char*) strstr_delimiter(strbuf, strold, delimiters);

	strncpy(strret, strbuf, (p-strbuf));
	strret[p-strbuf] = 0;
	posold = p+szold;
	posnews = strret+(p-strbuf);
	strcpy(posnews, strnew);
	posnews += sznew;

	while(n > 0) {
		if(!(p = strstr_delimiter(posold, strold, delimiters)))
			break;
		strncpy(posnews, posold, p-posold);
		posnews[p-posold] = 0;
		posnews += (p-posold);
		strcpy(posnews, strnew);
		posnews += sznew;
		posold = p+szold;
	}

	strcpy(posnews, posold);
	return strret;
}

template <class T> T Singleton<T>::mInstance = T();
template <class T>  T* Singleton<T>::Instance() {
	return &mInstance;
}


class MyClan: CEventListener {
	// matchId -> lastEventId
	map<string, string> matchEventIds;

public:
	MyClan(CLI *cli);

	void GenericHandleDone(CloudBuilder::eErrorCode code, const CloudBuilder::CCloudResult *result);
	void SetupDone(CloudBuilder::eErrorCode ec, const CloudBuilder::CCloudResult *res);
	void LoginDone(CloudBuilder::eErrorCode code, const CloudBuilder::CCloudResult *result);
	void LogoutDone(CloudBuilder::eErrorCode code, const CloudBuilder::CCloudResult *result);
	void RestoreSessionDone(CloudBuilder::eErrorCode code, const CloudBuilder::CCloudResult *result);
	void readbinDone(CloudBuilder::eErrorCode code, const CloudBuilder::CCloudResult *result);
	void downloadDone(CloudBuilder::eErrorCode code, const CloudBuilder::CCloudResult *result, const char *path);
	void uploadDone(CloudBuilder::eErrorCode code, const CloudBuilder::CCloudResult *result, char *pointer);
	
	CLI *mCLI;

	char pathavatar[200];

	eErrorCode parse(int argc, const char **argv);
	void endCommandWith(eErrorCode code, const CCloudResult *optionalResult = NULL) {
		gCLI->endCmd(code, optionalResult);
	}

	void ping(int argc, const char **argv) {
		CClan::Instance()->Ping(MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void push(int argc, const char **argv) {
		const char *domain = argc > 3 ? argv[3] : "private";
		const char *gamer = argv[0];
		CHJSON *json = JSON(1);
		CHJSON *notif = argc> 2 ? JSON(2) : NULL;

		CUserManager::Instance()->PushEvent(domain, gamer, json, notif, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void loginanonymous(int argc, const char **argv) {
		CUserManager::Instance()->LoginAnonymous(MakeResultHandler(this, &MyClan::LoginDone));
	}

	void login(int argc, const char **argv) {
		CHJSON j;
		j.Put("id", argv[0]);
		j.Put("secret", argv[1]);
		if (argc>2) j.Put("options", JSON(2));
		j.Put("network", argc> 3 ? argv[3] : "email");
		CUserManager::Instance()->LoginNetwork(&j, MakeResultHandler(this, &MyClan::LoginDone));
	}

	void resumesession(int argc, const char **argv) {
		CHJSON j;
		j.Put("id", argv[0]);
		j.Put("secret", argv[1]);
		j.Put("network", "anonymous");
		if (argc>2) j.Put("options", JSON(2));
		CUserManager::Instance()->ResumeSession(&j, MakeResultHandler(this, &MyClan::LoginDone));
	}

	void loginwith(int argc, const char **argv) {
		CHJSON config;
		config.Put("network", argv[0]);
		config.Put("id", argv[1]);
		config.Put("secret", argv[2]);
		if (argc> 2) config.Put("options", JSON(3));
		CUserManager::Instance()->LoginNetwork(&config, MakeResultHandler(this, &MyClan::LoginDone));
	}

	void linkwith(int argc, const char **argv) {
		CUserManager::Instance()->Link(argv[0], MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void unlink(int argc, const char **argv) {
		CUserManager::Instance()->Unlink(argv[0], MakeResultHandler(this, &MyClan::GenericHandleDone));
	}
	
	void convertto(int argc, const char **argv) {
		CHJSON config;
		config.Put("network", argv[0]);
		if (argc > 2) {
			config.Put("id", argv[1]);
			config.Put("secret", argv[2]);
		}
		CUserManager::Instance()->Convert(MakeResultHandler(this, &MyClan::GenericHandleDone), &config);
	}

	void mailpassword(int argc, const char **argv) {
		CHJSON j;
		j.Put("email",  argv[0]);
		j.Put("title", "Use this shortcode to connect again...");
		j.Put("body", "Your shortcode is [[SHORTCODE]] or you can click on maccli://cotc/token=[[SHORTCODE]]");
		j.Put("from", "noreply@clanofthecloud.com");
		CUserManager::Instance()->MailPassword(&j, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void changepassword(int argc, const char **argv) {
		CUserManager::Instance()->ChangePassword(argv[0], MakeResultHandler(this, &MyClan::GenericHandleDone));
	}
	
	void changeemail(int argc, const char **argv) {
		CUserManager::Instance()->ChangeEmail(argv[0], MakeResultHandler(this, &MyClan::GenericHandleDone));
	}
	
	void profile(int argc, const char **argv) {
		CUserManager::Instance()->GetProfile(MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void setprofile(int argc, const char **argv) {
		CHJSON *json = JSON(0);
		if (json==NULL)
			return endCommandWith(enBadParameters);

		CUserManager::Instance()->SetProfile(json, MakeResultHandler(this, &MyClan::GenericHandleDone));
		delete json;
	}

	void listusers(int argc, const char** argv) {
		CTribeManager::Instance()->ListUsers(argv[0], argc >= 2 ? atoi(argv[1]) : 10, argc >= 3 ? atoi(argv[2]) : 0, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

/*	void checkuser(int argc, const char** argv) {
		CUserManager::Instance()->CheckUser(argv[0], MakeResultHandler(this, &MyClan::GenericHandleDone));
	}*/

	void batch(int argc, const char** argv) {
		CHJSON j;
		j.Put("name", argv[0]);
		if (argc>2) j.Put("domain", argv[2]);
		CUserManager::Instance()->Batch(MakeResultHandler(this, &MyClan::GenericHandleDone), &j, JSON(1));
	}

	void gbatch(int argc, const char** argv) {
		CHJSON j;
		j.Put("name", argv[0]);
		if (argc>2) j.Put("domain", argv[2]);
		CGameManager::Instance()->Batch(MakeResultHandler(this, &MyClan::GenericHandleDone), &j, JSON(1));
	}

	void userexist(int argc, const char** argv) {
		CUserManager::Instance()->UserExist(argv[0], argv[1], MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void friends(int argc, const char **argv) {
		CTribeManager::Instance()->ListFriends(MakeResultHandler(this, &MyClan::GenericHandleDone), argc > 0 ? argv[0] : NULL);
	}

	void friendsof(int argc, const char **argv) {
		CTribeManager::Instance()->ListNetworkFriends(MakeResultHandler(this, &MyClan::GenericHandleDone), JSON(0));
	}

	void publishon(int argc, const char **argv) {
		CHJSON j;
		if (argc == 2) {
			j.Put("message", argv[1]);
		} else {
			j.Put("link", "http://www.clanofthecloud.com");
			j.Put("picture", "http://clanofthecloud.com/blog/wp-content/uploads/2011/11/Icon_CotC_96x96.png");
			j.Put("name", "Publish me!");
			j.Put("body", "I want to fill my empty wall from Clan of the Cloud games.");
		}
 		CUserManager::Instance()->Publish(argv[0], &j, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

/*	eErrorCode invitebymail(int argc, const char **argv) {
		char message[1000];
		sprintf(message, "<p>%s wants you to join the Clan and requests you as a friend.</p>", CUserManager::Instance()->GetDisplayName());
		CTribeManager::Instance()->InviteFriendByMail(argv[0], "Join the Clan !", message, MakeResultHandler(this, &MyClan::GenericHandleDone));
		return enNoErr;
	}*/

/*	eErrorCode invitefb(int argc, const char **argv)
	{
		char message[1000];

		sprintf(message, "%s wants you to join the Clan and requests you as a friend.", CUserManager::Instance()->GetDisplayName());
		CHJSON *j = new CHJSON();

		j->Put("link", "http://www.clanofthecloud.com");
		j->Put("picture", "http://clanofthecloud.com/blog/wp-content/uploads/2011/11/Icon_CotC_96x96.png");
		j->Put("name", "Join the Clan !");
		j->Put("body", message);
		CTribeManager::Instance()->InviteFriendByFBID(argv[0], j,MakeResultHandler(this, &MyClan::GenericHandleDone));
		delete j;
		return enNoErr;
	}*/

/*	eErrorCode invitegp(int argc, const char **argv)
	{
		char message[1000];

		sprintf(message, "%s wants you to join the Clan and requests you as a friend.", CUserManager::Instance()->GetDisplayName());
		CHJSON *j = new CHJSON();

		j->Put("link", "http://www.clanofthecloud.com");
		j->Put("picture", "http://clanofthecloud.com/blog/wp-content/uploads/2011/11/Icon_CotC_96x96.png");
		j->Put("name", "Join the Clan !");
		j->Put("body", message);
		CTribeManager::Instance()->InviteFriendByGooglePlusID(argv[0], j, MakeResultHandler(this, &MyClan::GenericHandleDone));
		delete j;
		return enNoErr;
	}*/

	void friendstatus(int argc, const char **argv) {
		CHJSON *json = JSON(0);
		CTribeManager::Instance()->ChangeRelationshipStatus(MakeResultHandler(this, &MyClan::GenericHandleDone), json);
	}

	void blacklist(int argc, const char **argv) {
		CTribeManager::Instance()->BlacklistFriends(MakeResultHandler(this, &MyClan::GenericHandleDone), argc >0 ? argv[0] : NULL);
	}


	void score(int argc, const char **argv) {
		CGameManager::Instance()->Score(MakeResultHandler(this, &MyClan::GenericHandleDone), std::atol(argv[1]), argv[0], argc>3 ? argv[3] : "hightolow", argc>2 ? argv[2] : NULL, argc>4 ? ISTRUE(4) : false, argc>5 ? argv[5]:"private");
	}

	void rank(int argc, const char **argv) {
		CGameManager::Instance()->GetRank(MakeResultHandler(this, &MyClan::GenericHandleDone), std::atol(argv[1]), argv[0], argc>2 ? argv[2] : "private");
	}

	void highscore(int argc, const char **argv) {
		CGameManager::Instance()->BestHighScore(MakeResultHandler(this, &MyClan::GenericHandleDone), 10, argc>1 ? atoi(argv[1]) : 1, argv[0], argc>2 ? argv[2] : "private");
	}

	void centeredscore(int argc, const char **argv) {
		CGameManager::Instance()->CenteredScore(MakeResultHandler(this, &MyClan::GenericHandleDone), 10, argv[0], argc>1 ? argv[1] : "private");
	}

	void friendbestscore(int argc, const char **argv) {
		CTribeManager::Instance()->FriendsBestHighScore(MakeResultHandler(this, &MyClan::GenericHandleDone), 10, argc>1 ? atoi(argv[1]) : 1, argv[0], argc>2 ? argv[2] : "private" );
	}

	void userbestscores(int argc, const char **argv) {
		CGameManager::Instance()->UserBestScores(MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void outline(int argc, const char **argv) {
		CUserManager::Instance()->Outline(MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void logout(int argc, const char **argv) {
		CUserManager::Instance()->Logout(MakeResultHandler(this, &MyClan::LogoutDone));
	}

	void setproperties(int argc, const char **argv) {
		CHJSON *json = JSON(0);
		CUserManager::Instance()->SetProperties(MakeResultHandler(this, &MyClan::GenericHandleDone), json, argc> 1 ? argv[1]: "private");
		delete json;
	}

	void properties(int argc, const char **argv) {
		CUserManager::Instance()->GetProperties(MakeResultHandler(this, &MyClan::GenericHandleDone), argc> 0 ? argv[0]: "private");
	}

	void setproperty(int argc, const char **argv) {
		CHJSON *json = JSON(0);
		CUserManager::Instance()->SetProperty(MakeResultHandler(this, &MyClan::GenericHandleDone), json, argc> 1 ? argv[1]: "private" );
		delete json;
	}
	
	void property(int argc, const char **argv) {
		CUserManager::Instance()->GetProperty(MakeResultHandler(this, &MyClan::GenericHandleDone), argv[0], argc> 1 ? argv[1]: "private");
	}

	void delproperty(int argc, const char **argv) {
		CUserManager::Instance()->DeleteProperty(MakeResultHandler(this, &MyClan::GenericHandleDone), argv[0], argc> 1 ? argv[1]: "private");
	}

	void findopponents(int argc, const char **argv) {
		CHJSON *json = JSON(0);
		CTribeManager::Instance()->FindOpponents(MakeResultHandler(this, &MyClan::GenericHandleDone), json, argc> 1 ? argv[1]: "private");
		delete json;
	}

	void transaction(int argc, const char **argv) {
		CHJSON *json = JSON(0);

		CHJSON tx;
		tx.Put("transaction", json);
		if (argc>1) tx.Put("description", argv[1]);
		if (argc>2) tx.Put("domain", argv[2]);
		
		CUserManager::Instance()->TransactionExtended(&tx, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void balance(int argc, const char **argv) {
		const char *domain = (argc>0) ? argv[0] : NULL;
		CUserManager::Instance()->Balance(domain, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void txhistory(int argc, const char **argv) {
		CHJSON *json = (argc>0) ? JSON(0) : new CHJSON();
		const char *domain = (argc>1) ? argv[1] : NULL;
		CUserManager::Instance()->TxHistory(domain, json, MakeResultHandler(this, &MyClan::GenericHandleDone));
		delete json;
	}

	void achievements(int argc, const char **argv) {
		CHJSON config;
		if (argc > 0) {
			config.Put("domain", argv[0]);
		}
		CUserManager::Instance()->ListAchievements(&config, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void achgamerdata(int argc, const char **argv) {
		CHJSON config;
		config.Put("name", argv[0]);
		config.Put("data", JSON(1));
		if (argc>2) config.Put("domain", argv[2]);

		CUserManager::Instance()->SetAchievementData(&config, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void earnach(int argc, const char **argv) {
		CHJSON *data = argc > 2 ? JSON(2) : NULL;
		int increment = argc > 1 ? atoi(argv[1]) : 1;

		CUserManager::Instance()->EarnAchievement(argv[0], increment, data, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void resetachs(int argc, const char **argv) {
		const char *domain = argc > 0 ? argv[0] : NULL;
		CUserManager_ResetAchievements(domain, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void kvread(int argc, const char **argv) {
		CHJSON config;
		if (argc > 1) {
			config.Put("domain", argv[1]);
		}
		if (*argv[0] != '*') {
			config.Put("key", argv[0]);
		}
		CUserManager::Instance()->KeyValueRead(&config, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void kvwrite(int argc, const char **argv) {
		CHJSON config;
		if (argc > 2) {
			config.Put("domain", argv[2]);
		}
		// argv[1] contains the JSON string
		if (*argv[0] != '*') {
			config.Put("key", argv[0]);
			config.Put("data", argv[1]);
		} else
			config.Put("data", JSON(1));

		CUserManager::Instance()->KeyValueWrite(&config, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void kvdel(int argc, const char **argv) {
		CHJSON config;
		if (argc > 1) {
			config.Put("domain", argv[1]);
		}
		if (*argv[0] != '*') {
			config.Put("key", argv[0]);
		}
		CUserManager::Instance()->KeyValueDelete(&config, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void binread(int argc, const char **argv) {
		CHJSON json;
		if (argc > 1) json.Put("domain", argv[1]);
		json.Put("key", argv[0]);
		CUserManager::Instance()->BinaryRead(&json, MakeResultHandler(this, &MyClan::readbinDone));
	}
	
	void binwrite(int argc, const char **argv) {
		CHJSON json;
		size_t size = atol(argv[1]);
		void *pointer = (void *)loremipsum;
		if (size > strlen(loremipsum)) size = strlen(loremipsum);

		json.Put("key", argv[0]);
		if (argc > 2) json.Put("domain", argv[2]);
		
		CUserManager::Instance()->BinaryWrite(&json, pointer, size, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void bindel(int argc, const char **argv) {
		CHJSON json;
		if (argc > 1) json.Put("domain", argv[1]);
		json.Put("key", argv[0]);
		CUserManager::Instance()->BinaryDelete(&json, MakeResultHandler(this, &MyClan::readbinDone));
	}

	void download(int argc, const char **argv) {
		CHJSON json;
		if (argc > 2) json.Put("domain", argv[2]);
		json.Put("key", argv[0]);
		const char *path = argv[1];
		CUserManager::Instance()->BinaryRead(&json, MakeResultHandler(this, &MyClan::downloadDone, path));
	}
	
	void upload(int argc, const char **argv) {
		const char *path = argv[0];
		FILE *fp = fopen(path, "rb");
		if (fp==NULL)
		{
			mCLI->logger("file not found !");
			return endCommandWith(enCanceled);
		}
		fseek(fp, 0, SEEK_END);
		long fsize = ftell(fp);
		fseek(fp, 0, SEEK_SET);
		char *content = (char *)malloc(fsize);
		fread(content, fsize, 1, fp);
		fclose(fp);
		
		CHJSON json;
		json.Put("key", argv[1]);
		if (argc > 2) json.Put("domain", argv[2]);
		
		CUserManager::Instance()->BinaryWrite(&json, content, fsize, MakeResultHandler(this, &MyClan::uploadDone, content));
	}

	void gkvread(int argc, const char **argv) {
		const char *domain = (argc>1) ? argv[1] : NULL;
		const char *key = *argv[0]!='*' ? argv[0] : NULL;
		CHJSON j;
		j.Put("domain", domain);
		if (key)
			j.Put("key", key);
		CGameManager::Instance()->KeyValueRead(&j, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void gkvwrite(int argc, const char **argv) {
		const char *key = *argv[0]!='*' ? argv[0] : NULL;
		CHJSON *json = JSON(1);
		const char *domain = (argc>2) ? argv[2] : NULL;
		CHJSON j;
		j.Put("domain", domain);
		if (key)
			j.Put("key", key);
		j.Put("data", json);
		//CGameManager::Instance()->KeyValueWrite(&j, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void gkvdel(int argc, const char **argv) {
		const char *domain = (argc>1) ? argv[1] : NULL;
		const char *key = *argv[0]!='*' ? argv[0] : NULL;
		CHJSON j;
		j.Put("domain", domain);
		if (key)
			j.Put("key", key);
		//CGameManager::Instance()->KeyValueDelete(&j, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void gbinread(int argc, const char **argv) {
		const char *domain = (argc>1) ? argv[1] : NULL;
		const char *key = argv[0];
		CHJSON j;
		j.Put("domain", domain);
		j.Put("key", key);
		CGameManager::Instance()->BinaryRead(&j, MakeResultHandler(this, &MyClan::readbinDone));
	}
	
	void gbinwrite(int argc, const char **argv) {
		const char *key = argv[0];
		size_t size = atol(argv[1]);
		if (size > strlen(loremipsum)) size = strlen(loremipsum);
		
		const char *domain = (argc>2) ? argv[2] : NULL;
		
		CHJSON j;
		j.Put("domain", domain);
		j.Put("key", key);
		//void *pointer = (void *)loremipsum;
		//CGameManager::Instance()->BinaryWrite(&j, pointer, size, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void gbindel(int argc, const char **argv) {
		const char *domain = (argc>1) ? argv[1] : NULL;
		const char *key = argv[0];
		CHJSON j;
		j.Put("domain", domain);
		j.Put("key", key);
		//CGameManager::Instance()->BinaryDelete(&j, MakeResultHandler(this, &MyClan::readbinDone));
	}

	void terminate(int argc, const char **argv) {
		CClan::Instance()->Terminate();
		endCommandWith(enNoErr);
	}

	void godfathercode(int argc, const char **argv) {
		CUserManager::Instance()->GetGodfatherCode(MakeResultHandler(this, &MyClan::GenericHandleDone), argc >0 ? argv[0]: "private");
	}

	void godfather(int argc, const char **argv) {
		CUserManager::Instance()->GetGodfather(MakeResultHandler(this, &MyClan::GenericHandleDone), argc >0 ? argv[0]: "private");
	}

	void godchildren(int argc, const char **argv) {
		CUserManager::Instance()->GetGodchildren(MakeResultHandler(this, &MyClan::GenericHandleDone), argc >0 ? argv[0]: "private");
	}

	void setgodfather(int argc, const char **argv) {
		CHJSON *j = NULL;
		if (argc>1) j = JSON(1);
		CUserManager::Instance()->SetGodfather(argv[0], j, MakeResultHandler(this, &MyClan::GenericHandleDone));
	}

	void creatematch(int argc, const char **argv) {
		// creatematch maxPlayers [domain [description [customProperties [shoe]]]
		CHJSON config;
		config.Put("maxPlayers", atoi(argv[0]));
		if (argc > 1) { config.Put("domain", argv[1]); }
		if (argc > 2) { config.Put("description", argv[2]); }
		if (argc > 3) { config.Put("customProperties", JSON(3)); }
		if (argc > 4) { config.Put("shoe", JSON(4)); }
		CMatchManager::Instance()->CreateMatch(MakeResultHandler(this, &MyClan::HandleReturnedMatch), &config);
	}

	void matches(int argc, const char **argv) {
		// matches [json]
		owned_ref<CHJSON> config;
		config <<= (argc > 0 ? JSON(0) : new CHJSON);
		CMatchManager::Instance()->ListMatches(MakeResultHandler(this, &MyClan::GenericHandleDone), config);
	}

	void match(int argc, const char **argv) {
		CHJSON config;
		config.Put("id", argv[0]);
		CMatchManager::Instance()->FetchMatch(MakeResultHandler(this, &MyClan::HandleReturnedMatch), &config);
	}

	void joinmatch(int argc, const char **argv) {
		// joinmatch id [osn]
		CHJSON config;
		config.Put("id", argv[0]);
		if (argc > 1) { config.Put("osn", JSON(1)); }
		CMatchManager::Instance()->JoinMatch(MakeResultHandler(this, &MyClan::HandleReturnedMatch), &config);
	}

	void inviteplayer(int argc, const char **argv) {
		// inviteplayer match_id gamer_id [osn]
		CHJSON config;
		config.Put("id", argv[0]);
		config.Put("gamer_id", argv[1]);
		if (argc > 2) { config.Put("osn", JSON(2)); }
		CMatchManager::Instance()->InvitePlayer(MakeResultHandler(this, &MyClan::HandleReturnedMatch), &config);
	}

	void dismissinvitation(int argc, const char **argv) {
		CHJSON config;
		config.Put("id", argv[0]);
		CMatchManager::Instance()->DismissInvitation(MakeResultHandler(this, &MyClan::GenericHandleDone), &config);
	}

	void movematch(int argc, const char **argv) {
		CHJSON config;
		config.Put("id", argv[0]);
		config.Put("move", JSON(1));
		config.Put("lastEventId", GetLastEventId(argv[0]));
		if (argc > 2) { config.Put("globalState", JSON(2)); }
		if (argc > 3) { config.Put("osn", JSON(3)); }
		CMatchManager::Instance()->PostMove(MakeResultHandler(this, &MyClan::HandleReturnedMatch), &config);
	}

	void drawmatchshoe(int argc, const char **argv) {
		CHJSON config;
		config.Put("id", argv[0]);
		config.Put("count", atoi(argv[1]));
		config.Put("lastEventId", GetLastEventId(argv[0]));
		if (argc > 2) { config.Put("osn", JSON(2)); }
		CMatchManager::Instance()->DrawFromShoe(MakeResultHandler(this, &MyClan::HandleReturnedMatch), &config);
	}

	void leavematch(int argc, const char **argv) {
		// leavematch id [osn]
		CHJSON config;
		config.Put("id", argv[0]);
		if (argc > 1) { config.Put("osn", JSON(1)); }
		CMatchManager::Instance()->LeaveMatch(MakeResultHandler(this, &MyClan::HandleReturnedMatch), &config);
	}

	void finishmatch(int argc, const char **argv) {
		CHJSON config;
		config.Put("id", argv[0]);
		config.Put("lastEventId", GetLastEventId(argv[0]));
		if (argc > 1) { config.Put("osn", JSON(1)); }
		CMatchManager::Instance()->FinishMatch(MakeResultHandler(this, &MyClan::HandleReturnedMatch), &config);
	}

	void deletematch(int argc, const char **argv) {
		CHJSON config;
		config.Put("id", argv[0]);
		CMatchManager::Instance()->DeleteMatch(MakeResultHandler(this, &MyClan::GenericHandleDone), &config);
	}

	void products(int argc, const char **argv) {
		CHJSON dummy;
		CStoreManager::Instance()->FetchProductInformation(MakeResultHandler(this, &MyClan::GenericHandleDone), &dummy);
	}

	void purchase(int argc, const char **argv) {
		CHJSON config;
		config.Put("productId", argv[0]);
		CStoreManager::Instance()->LaunchPurchase(MakeResultHandler(this, &MyClan::GenericHandleDone), &config);
	}

	void purchases(int argc, const char **argv) {
		CStoreManager::Instance()->GetPurchaseHistory(MakeResultHandler(this, &MyClan::GenericHandleDone), CHJSON::Empty());
	}

	void HandleReturnedMatch(eErrorCode code, const CCloudResult *result) {
		if (result->GetJSON()->Has("match")) {
			// Keep last event ID
			const CHJSON *matchNode = result->GetJSON()->Get("match");
			const char *matchId = matchNode->GetString("_id"), *lastEventId = matchNode->GetString("lastEventId");
			if (matchId && lastEventId) {
				matchEventIds[matchId] = lastEventId;
			}
		}
		return GenericHandleDone(code, result);
	}

	void listener(int argc, const char **argv) {
		CUserManager::Instance()->RegisterEventListener(argv[0], this);
		endCommandWith(enNoErr);
	}
	
	void indexset(int argc, const char **argv) {
		CHJSON config;
		config.Put("index", argv[0]);
		config.Put("objectid", argv[1]);
		config.Put("properties", JSON(2));
		if (argc > 3) config.Put("domain", argv[3]);
		if (argc > 4) config.Put("payload", JSON(4));
		CIndexManager::Instance()->IndexObject(MakeResultHandler(this, &MyClan::GenericHandleDone), &config);
	}

	void indexget(int argc, const char **argv) {
		CHJSON config;
		config.Put("index", argv[0]);
		config.Put("objectid", argv[1]);
		if (argc > 2) config.Put("domain", argv[2]);
		CIndexManager::Instance()->FetchObject(MakeResultHandler(this, &MyClan::GenericHandleDone), &config);
	}

	void indexdel(int argc, const char **argv) {
		CHJSON config;
		config.Put("index", argv[0]);
		config.Put("objectid", argv[1]);
		if (argc > 2) config.Put("domain", argv[2]);
		CIndexManager::Instance()->DeleteObject(MakeResultHandler(this, &MyClan::GenericHandleDone), &config);
	}

	void indexsearch(int argc, const char **argv) {
		CHJSON config;
		config.Put("index", argv[0]);
		config.Put("query", argv[1]);
		if (argc > 2) config.Put("domain", argv[2]);
		if (argc > 3) config.Put("sort", JSON(3));
		if (argc > 4) config.Put("limit", atoi(argv[4]));
		if (argc > 5) config.Put("skip", atoi(argv[5]));
		CIndexManager::Instance()->Search(MakeResultHandler(this, &MyClan::GenericHandleDone), &config);
	}

	void onfailure(int argc, const char **argv) {
		// Never retry
		struct OnFailureType1: CDelegate<void (CHttpFailureEventArgs&)> {
			OnFailureType1() : CDelegate(this, &OnFailureType1::Done) {}
			void Done(CHttpFailureEventArgs &args) {
				args.Abort();
			}
		};
		// Retry once after 5 seconds, then stop
		struct OnFailureType2: CDelegate<void (CHttpFailureEventArgs&)> {
			OnFailureType2() : CDelegate(this, &OnFailureType2::Done) {}
			void Done(CHttpFailureEventArgs &args) {
				int retryCount = (int) args.UserData();
				if (retryCount == 0) {
					args.RetryIn(5000);
					args.SetUserData(retryCount + 1, false);
				}
				else
					args.Abort();
			}
		};
		switch (atoi(argv[0])) {
		case 0:
			CClan::Instance()->SetHttpFailureCallback(NULL);
			break;
		case 1:
			CClan::Instance()->SetHttpFailureCallback(new OnFailureType1());
			break;
		case 2:
			CClan::Instance()->SetHttpFailureCallback(new OnFailureType2());
			break;
		default:
			console("Unrecognized type %s", argv[0]);
			break;
		}
		endCommandWith(enNoErr, new CCloudResult());
	}

	virtual void onEventReceived(const char *domain, const CCloudResult *event) {
		console("received on `%s`", domain);
		if (event) consoleJson("", event->GetJSON());
		//OUTPUT("received on `%s`\n", domain);
		//OUTPUT("event : %s\n", event->printFormatted());
	}

	virtual void onEventError(eErrorCode errorCode, const char *domain, const CCloudResult *result) {
		console("Error with event on `%s` (%s)", domain, errorString(errorCode));
	}

private:
	const char *GetLastEventId(const char *matchId) {
		if (matchEventIds.find(matchId) == matchEventIds.end()) {
			console("Error: no last event ID stored for match %s, command will probably not work (please fetch the match first)", matchId);
			return NULL;
		}
		return matchEventIds[matchId].c_str();
	}
};


//////////////////////////// Commands ////////////////////////////
method CMD[] = {
	{
		"setupappid",
		"setupappid key secret [server]\n  key : appid of the game\n  secret : appid token\n  server : Server address (i.e. https://sandbox-api01.clanofthecloud.mobi ), or one of the preset aliases [prod, sandbox, dev].",
		2,3,
		NULL,
	},{
		"setup",
		"setup [app_alias] [server_alias]\n  app: alias for app (cloudbuilder, demo,..)\n  server : Server address (i.e. https://sandbox-api01.clanofthecloud.mobi ), or one of the preset aliases [prod, sandbox, dev].",
		0,2,
		NULL,
	},{
		"script",
		"script [name]\n  Run the script named 'name'. If name is not provided, lists the directory where scripts are loooked for.",
		0,1,
		NULL,
	},{
		"context",
		"context [name]\n  load file named 'name' as context data.",
		1,1,
		NULL,
	},{
		"cd",
		"cd path\n  Change the current directory to path, scripts will be look into this path",
		1,1,
		NULL,
	},{
		"cmd",
		"cmd [n]\n  execute cmd n",
		0,1,
		NULL,
	},{
		"set",
		"set value\n  set value to var name (use with $n)",
		0,1,
		NULL,
	},

// SDK interfaces......

	ADD(ping, 0,0,				"ping the server)")
	ADD(terminate, 0,0,			"terminates the running instance (need to call setup afterwards)")
	ADD(listener, 1,1, 			"listener domain\n  register an event listener for `domain`")
	ADD(push, 2,4,			  "push gamerid json [osn] [domain]")
	ADD(loginanonymous, 0,0, 	"loginanonymous")
	ADD(login, 2,4, 			"login user pass [optionsJson] [network]\n  default network is 'email'")
	ADD(resumesession, 2,3, 	"resumesession user_id user_secret [optionsJson]\n resume session")
	ADD(loginwith, 3,4, 		"loginwith network id secret [optionsJson]\n  login with network : facebookId, googleplusId, gamecenter")
	ADD(linkwith, 1,1,		  "linkwith\n  link current account with network : facebook, google, gamercenter")
	ADD(unlink, 1,1, 			"unlink network\n  unlink current account with network facebook, google, gamecenter")
	ADD(convertto, 1,3,		  	"convertto network[, id, secret]\n  convert current account to network: facebook, google, gamercenter, email")
	ADD(mailpassword, 1,1, 		"mailpassword email\n  send a mail with a shortcode, use it un loginwith 'restore'")
	ADD(changepassword, 1,1, 	"changepassword newpass")
	ADD(changeemail, 1,1, 		"changeemail newemail")
	ADD(profile, 0,0, 			"profile")
	ADD(setprofile, 1,1, 		"setprofile aJSon")
	ADD(batch, 2,3, 			"batch name inputJson [domain]\n  User batch")
	ADD(gbatch, 2,3, 			"batch name inputJson [domain]\n  Game batch")
//	ADD(checkuser, 1,1, 		"checkuser pseudo/email\n  returns true if pseudo/email match")
	ADD(userexist, 2,2, 		"userexist ID network\n  network should be (0:facebook, 1:googleplus, 2:gamecenter)\n  returns true if ID match")
	ADD(listusers, 1,3, 		"users pattern\n  returns list of users with pseudo/email matching pattern")
	ADD(friendsof, 1,1, 		"friendsof  json\n  returns list of friends from network= facebookId, googleplusId, gamecenter\n  json must contains network, firends and optionnally automatching")
	ADD(publishon, 1,2,			"publishon network messagen post message on <network> wall")
//	ADD(invitebymail, 1,1, 		"invitebymail email\n  invite friend by sending email")
//	ADD(invitefb, 1,1, 			"invitefb fbID\n  invite friend having fbID on facebook")
//	ADD(invitegp, 1,1, 			"invitegp gpID\n  invite friend having gpID on googleplus")

	ADD(friends, 0,1, 			"friends [domain]\n  returns list of friends")
	ADD(friendstatus, 1,1, 	"friendstatus {\"id\" : friend, \"status\": \"add\", \"osn\" : {\"en\": \"relation change\"}}\n  change the state for the user\n  state must be in (add, forget, blacklist)")
	ADD(blacklist, 0,1, 		"blacklist [domain]\n  return list of blacklisted friends")

	ADD(userbestscores, 0,0,	"userbestscores\n")
	ADD(score, 2,6, 			"score mode value [info] [type] [mayvary] [domain]\n  new score in mode\n  type is 0: HighToLow, or 1: LowToHigh, default is 0\n  infos is a user information, defaut is empty\n  mayvary true if test on highest shoudn't be done")
	ADD(rank, 2,3, 			"rank mode value [domain]\n  get rank in mode\n")
	ADD(centeredscore, 1,2, 	"centered mode [domain]\n")
	ADD(highscore, 1,3, 		"highscore mode [page] [domain]\n")
	ADD(friendbestscore, 1,3, "friendbestscore mode [page] [domain]\n")

	
	ADD(logout, 0,0, 			"logout")
	ADD(outline, 0,0, 			"outline")

	ADD(setproperties, 1,2,	"setproperties json [domain]\n  store user's properties used for findopponents")
	ADD(properties, 0,1,		"properties [domain]\n  display user's properties used for findopponents")
	ADD(setproperty, 1,2,	 	"setproperty json [domain]\n  store user's propertt , json must be {'key' : keyname, 'value': 'content } used for findopponents")
	ADD(property, 1,2,			"property key [domain]\n  display user's property <key> used for findopponents")
	ADD(delproperty, 1,2,		"delproperty key [domain]\n  delete user's property <key> used for findopponents")
	ADD(findopponents, 1,2,	"findopponents json [domain]\n  find opponents according to the filter")

	ADD(transaction, 1,4,	   "transaction jsonTransaction [stringDesc] [domain]\n  add new transaction {'gold': 100} ")
	ADD(balance, 0,1,		   "balance [domain]\n  returns balance for logged user")
	ADD(txhistory, 0,2,		 "txhistory [aJson] [domain]\n  transactions history for all unit or the specified one {'unit':'Gold' [, 'skip':0, 'limit':10 ] }")
	
	ADD(achievements, 0,1,	  "achievements [domain]\n  shows current state of achievements for the current player")
	ADD(achgamerdata, 2,3,    "achgamerdata achname json [domain]\n  sets data for a given achievement")
	ADD(earnach, 1,3,         "achgamerdata achname [increment [json]]\n  increments an achievement and optionally sets gamer data")
	ADD(resetachs, 0,1,      "resetachs [domain]\n  resets ALL achievement data for this domain, acting on behalf of the current logged user")

	ADD(kvread, 1,2,			"kvread key [domain]\n  key could be '*' to get all keys")
	ADD(kvwrite, 2,3,		   "kvwrite key json [domain]\n  key could be '*' to replace globally all keys")
	ADD(kvdel, 1,2,				"kvdelete key [domain]\n  key could be '*' to get all keys")
	ADD(binread, 1,2,		   "binread key [domain]")
	ADD(binwrite, 2,3,		  "binwrite key size [domain]\n size is the length of random bytes to write")
	ADD(bindel, 1,2,		   "bindel key [domain]")
	ADD(upload, 2,3,		   "upload path key [domain]")
	ADD(download, 2,3,		  	"download key path [domain]")
	ADD(gkvread, 1,2,		   "gkvread key [domain]\n  key could be '*' to get all keys")
	ADD(gkvwrite, 2,3,		  "gkvwrite key json [domain]\n  key could be '*' to replace globally all keys")
	ADD(gkvdel, 1,2,			"gkvdelete key [domain]\n  key could be '*' to get all keys")
	ADD(gbinread, 1,2,		  "gbinread key [domain]")
	ADD(gbindel, 1,2,		  "gbindel key [domain]")
	ADD(gbinwrite, 2,3,		 "gbinwrite key size [domain]\n size is the length of random bytes to write")

	ADD(godchildren, 0,1, 		"godchildren [domain]\n  return list of godchildren of the user")
	ADD(godfather, 0,1, 		"godfather [domain]\n  return godfather of the user")
	ADD(godfathercode, 0,1, 	"godfathercode [domain]\n  return a code to allow to the user to be godfather")
	ADD(setgodfather, 1,2, 		"setgodfather code [json]\n  set the user determined by the code to be the godfather of current user\n  json may contain 'domain', 'maturity' in days and 'reward' a json transaction { transaction : j [[, description : s, domain: s]] }")

	ADD(creatematch, 1, 5, 		"creatematch maxPlayers [domain [description [customProperties [shoe]]]\n  creates a match")
	ADD(matches, 0, 1, 			"matches [json]\n  return the list of matches. The JSON may contain filter, participating, invited, full, limit, skip.")
	ADD(match, 1, 1, 			"match id\n  return a match with the given ID.")
	ADD(joinmatch, 1, 2, 		"joinmatch id [osn]\n  joins the match with the given ID.")
	ADD(inviteplayer, 2, 3, 	"inviteplayer match_id gamer_id [osn]\n  invites a player to the match.")
	ADD(dismissinvitation, 1, 1, "dismissinvitation match_id\n  dismisses any previous invitation received for a given match.")
	ADD(movematch, 2, 4, 		"movematch match_id move [globalState [osn]]\n  posts a move in a match.")
	ADD(drawmatchshoe, 2, 3, 		"drawmatchshoe match_id count [osn]\n  draws one or more items from the shoe.")
	ADD(leavematch, 1, 2, 		"leavematch id [osn]\n  leaves the match with the given ID.")
	ADD(finishmatch, 1, 2, 		"finishmatch id [osn]\n  finishes the match with the given ID.")
	ADD(deletematch, 1, 1, 		"deletematch id\n  deletes the match with the given ID.")

	ADD(products, 0, 0, 		"products\n  lists the available products for purchase.")
	ADD(purchase, 1, 1, 		"purchase productId\n  launches a purchase for the given product.")
	ADD(purchases, 0, 0, 		"purchases\n  Fetches the history of purchases for this user.")

	ADD(indexset, 3, 5,			"indexset indexName objectid properties [domain [payload]]\n  indexes a new object. E.g. indexset test 1234 {\"hello\": \"world\", \"name\", \"me\"}")
	ADD(indexget, 2, 3,			"indexget indexName objectid [domain]\n  fetches an indexed object. E.g. indexget test 1234")
	ADD(indexdel, 2, 3,			"indexdel indexName objectid [domain]\n  removes an indexed object. E.g. indexdel test 1234")
	ADD(indexsearch, 2, 6,		"indexsearch indexName query [domain [sortingProps [limit [skip]]]]\n  searches for indexed objects. E.g. indexsearch temp hello:world private [\"name:asc\"]")

	ADD(onfailure, 1, 1, 		"onfailure type\n  Sets the HTTP failure callback behaviour. Type=0 = default (retry), 1=do not retry, 2=retry once after 5 sec")


	{NULL},
};

//////////////////////////// MyClan implementation ////////////////////////////
void MyClan::SetupDone(CloudBuilder::eErrorCode ec, const CloudBuilder::CCloudResult *res) {
	if (CClan::Instance()->isUserLogged()) {
		CUserManager::Instance()->RegisterEventListener("private", this);
	}
	endCommandWith(ec, res);
}

void MyClan::LoginDone(CloudBuilder::eErrorCode ec, const CloudBuilder::CCloudResult *res) {
	CUserManager::Instance()->RegisterEventListener("private", this);
	endCommandWith(ec, res);
}

void MyClan::LogoutDone(CloudBuilder::eErrorCode ec, const CloudBuilder::CCloudResult *res) {
	endCommandWith(ec, res);
}

void MyClan::GenericHandleDone(CloudBuilder::eErrorCode ec, const CloudBuilder::CCloudResult *res) {
	endCommandWith(ec, res);
}

void MyClan::readbinDone(CloudBuilder::eErrorCode ec, const CloudBuilder::CCloudResult *res) {
	if (res->HasBinary()) {
		size_t size = res->BinarySize();
		console("Binary size = %ld", size);
		if (size>0 && size < 500) { // quick and dirty test...
			char *p = ( char *)res->BinaryPtr();
			p[size-1] = 0;
			console("bin = '%s'", p);
		}
	}
	endCommandWith(ec, res);
}

void MyClan::downloadDone(CloudBuilder::eErrorCode ec, const CloudBuilder::CCloudResult *res, const char *path) {
	if (res->HasBinary()) {
		size_t size = res->BinarySize();
		console("Binary size = %ld", size);
		FILE *fp = fopen(path, "wb");
		fwrite(res->BinaryPtr(), size, 1, fp);
		fclose(fp);
	}
	endCommandWith(ec, res);
}

void MyClan::uploadDone(CloudBuilder::eErrorCode ec, const CloudBuilder::CCloudResult *res, char *pointer) {
	free(pointer),
	endCommandWith(ec, res);
}

void MyClan::RestoreSessionDone(CloudBuilder::eErrorCode ec, const CloudBuilder::CCloudResult *res) {
	console("Restoring session...")
	if (ec) mCLI->logger(errorString(ec));
	if (res) consoleJson("result", res->GetJSON());
}

MyClan::MyClan(CLI* cli) {
	mCLI = cli;
}

eErrorCode MyClan::parse(int argc, const char **argv)
{
	method *p = CMD;
	int i;
	for (i=0; p->name!=NULL; i++, p++)
		if (strcmp(argv[0], p->name)==0)
		{
			if(argc-1 >= p->min && argc-1 <= p->max)
			{
				(*this.*(p->call))(--argc, ++argv);
				return enNoErr;
			}
			else
			{
				console("bad numbers of parameters !")
				console("%s", p->help);
				return enBadParameters;
			}
			break;
		}

	console("command not found !")
	return enBadParameters;
}

//////////////////////////// CLI ////////////////////////////
static int compar(const void *a, const void *b)
{
	return strcmp(((method *)a)->name, ((method *)b)->name);
}

CLI::CLI()
{
	myClan = NULL;
	mLine = 0;
	mSize = 0;
	mExpected = NULL;
	mPassed = 0;
	mMissed = 0;
	mSkipped = 0;
	mVar = NULL;
	mMissedLog = NULL;
	mModeScript = false;
	mWorking = false;
	mFlowScript = 0;

	CotCHelpers::Init();

	method *p = CMD;
	int nb = 0;
	for (nb=0; p->name!=NULL; p++, nb++) ;

	qsort(CMD, nb, sizeof(method), compar);

	initFav();

	gCLI = this;

}

CLI::~CLI()
{
}

eErrorCode CLI::execute(const char *li)
{

	char *templine = strdup(li);
	char *line;

	const char *errorvar = replaceVar(templine, &line);
	if (errorvar) {
		logger(errorvar, kERR);
		return enBadParameters;
	}

	int argc = 0;
	char* argv[10];
	int error = this->tokenize(line, &argc, argv);
    struct timeval tv; gettimeofday(&tv, NULL);
	mLastExecuteStartTime = tv.tv_sec*1000.+(double)tv.tv_usec/1000.;

	if (error==0)
	{
		eErrorCode  ec;
		if (argc)
			ec = this->parse(argc,(const char **)argv);
		else
			ec = (eErrorCode) -1;

		free(line);
		return ec;
	}
	else
	{
		free(line);
		return enBadParameters;
	}
}

long CLI::millisecondsElapsedSinceLastExecute() {
    struct timeval tv; gettimeofday(&tv, NULL);
	return (long) (tv.tv_sec*1000.+(double)tv.tv_usec/1000. - mLastExecuteStartTime);
}

void CLI::endCmd(eErrorCode ec, const CCloudResult *res) {
	if (!mModeScript) {
	   if (res) consoleJson(">> ",res->GetJSON());
		stopActivity(ec);
	}
	else if (mExpected)
		checkExpected(res);
	else
		if (res) consoleJson(">> ", res->GetJSON());
	mWorking = false;
}

bool CLI::compareKey(const CHJSON *j, const CHJSON *jr, const char *key, bool store, char *error) {
	if (j->type() == CHJSON::jsonObject) {
		if (store) {
			const char * k = key;
			if (*key == '@') k = key+1;
			if (strrchr(k, '.')) {
				k = strrchr(k, '.') + 1;
			}
			if (jr->type() == CHJSON::jsonNumber) {
				mVar->Put(k, jr->valueInt());
				console("saving %s : %i", key, jr->valueInt());
			} else {
				mVar->Put(k, jr->valueString());
				console("saving %s : %s", key, jr->valueString());
			}
		}
		const CHJSON *cmp = j->Get(0);
		const char *op = cmp->name();
		if (strcmp (op, "exist")==0) {
			bool passed = (jr == NULL) ^ cmp->valueInt();
			if (!passed) sprintf(error, "`%s`: expected to %s ", key, cmp->valueInt() ? "exist" : "not exist");
			return  passed;
		} else if (jr == NULL) {
			sprintf(error, "%s key not found in result!", key);
			return false;
		} else if (strcmp (op, "empty")==0) {
			bool shouldBeEmpty = cmp->valueInt() != 0;
			bool isEmpty = jr->size() == 0;
			bool passed = (shouldBeEmpty == isEmpty);
			if (!passed) sprintf(error, "`%s`: expected to be%s empty", key, shouldBeEmpty ? "" : " not");
			return passed;
		} else if (strcmp (op, "gt")==0) {
			bool passed = jr->valueInt() > cmp->valueInt();
			if (!passed) sprintf(error, "`%s`:%d expected to be %s %d", key, jr->valueInt(), op, cmp->valueInt());
			return  passed;
		} else if (strcmp (op, "lt")==0) {
			bool passed = jr->valueInt() < cmp->valueInt();
			if (!passed) sprintf(error, "`%s`:%d expected to be %s %d", key, jr->valueInt(), op, cmp->valueInt());
			return  passed;
		} else if (strcmp (op, "is")==0) {
			CHJSON::jsonType type = jr->type();
			const char *exptype = cmp->valueString();
			bool passed =   (type==CHJSON::jsonArray && strcmp(exptype, "array")==0) ||
			(type==CHJSON::jsonNumber && strcmp(exptype, "number")==0) ||
			(type==CHJSON::jsonString && strcmp(exptype, "string")==0) ;
			if (!passed) sprintf(error, "`%s` expected to be %s", key, exptype);
			return  passed;
		} else if (strcmp (op, "contains")==0 || strcmp (op, "notContains")==0) {
			if ( jr->type() != CHJSON::jsonArray) {
				sprintf(error, "%s expected to be an array !", key);
				return false;
			}

			const CHJSON *target = cmp;
			bool passed = false;
			for(int d = 0; d<jr->size(); d++) {
				const CHJSON *val = jr->Get(d);
				const CHJSON *targval = target->Get(0);
				switch (targval->type()) {
					case CHJSON::jsonNumber:
						if (targval->valueInt()==val->GetInt(targval->name())) passed = true;
						break;
					case CHJSON::jsonString: {
						const char *s = val->GetString(targval->name());
						if (s && strcmp(targval->valueString(),s)==0 ) passed = true;
					} break;
					default: break;
				}
			}

			if (strcmp(op, "notContains")==0) passed = !passed;

			if (!passed)  {
				sprintf(error, "`%s` expected to contain %s", key, target->print().c_str());
			}
			return  passed;
		} else if (strcmp (op, "in")==0) {
			if ( cmp->type() != CHJSON::jsonArray) {
				sprintf(error, "%s : operator in request to be an array !", key);
				return false;
			}
			const CHJSON *ar = cmp;
			bool passed = false;
			for (int k=0; k < ar->size(); k++) {
				const CHJSON *option = ar->Get(k);
				if (option->type() != jr->type()) {
					sprintf(error, "`%s`: Bad type for Array", key);
					return false;
				}
				switch (option->type()) {
					case CHJSON::jsonNumber:
						if (option->valueInt() == jr->valueInt()) passed = true;
						break;
					case CHJSON::jsonString:
						if (strcmp(option->valueString(),  jr->valueString())==0) passed = true;
						break;
					default:
						break;
				}
			}
			if (!passed) {
				sprintf(error, "`%s`: expected to be in %s", key, ar->print().c_str());
			}
			return  passed;
		}
		else {
			sprintf(error, "Unknown operator `%s` for key `%s`", op, key);
			return false;
		}
	} else if (jr ==NULL) {
		sprintf(error, "%s key not found in result!", key);
		return false;
	} else if (j->type() != jr->type()) {
		if (j->type() == CHJSON::jsonFalse)
			sprintf(error, "Expected %s to be `false`", key);
		else if (j->type() == CHJSON::jsonTrue)
			sprintf(error, "Expected %s to be `true`", key);
		else
			sprintf(error, "Bad type for key %s", key);
		return false;
	} else switch (j->type()) {
		case CHJSON::jsonNumber:
			if( j->valueInt() != jr->valueInt()) {
				sprintf(error, "Expected %s to be `%d` but got `%d`", key, j->valueInt(), jr->valueInt());
				return false;
			}
			break;
		case CHJSON::jsonString:
			if(strcmp(j->valueString(),jr->valueString())!=0) {
				sprintf(error, "Expected %s to be `%s` but got `%s`", key, j->valueString(), jr->valueString());
				return false;
			}
			break;

		default:
			break;
	}
	return true;

}

bool CLI::compareExpected(const CCloudResult *res, char *error) {
	bool store = false;
	const char *keyname;
	
	int n = mExpected->size();
	for (int i=0; i<n; i++) {
		const CHJSON *j = mExpected->Get(i);
		char *key = strdup(j->name());
		if (*key == '@') {
			keyname = key+1;
			store  = true;
		} else
			keyname = key;
		if (strcmp(key, "****") == 0) {
			if (!compareKey(j, res->GetJSON(), keyname, store, error))
			{ free(key); return false; }
		} else if (strchr(key, '.') == NULL) {
			const CHJSON *json = res->GetJSON();
			if (json == NULL) {
				sprintf(error,"Can't find key `%s` as defined in`%s`", key, j->name());
				free(key);
				return false;
			}
			const CHJSON *jr = json->Get(keyname);
			if (!compareKey(j, jr, keyname, store, error))
				{ free(key); return false; }
		} else  {
			const CHJSON *jj;
			char *pch = strtok (key,".");
			if (*pch == '$') {
				jj = res->GetJSON();
				pch = strtok (NULL, ".");
			} else {
				jj = res->GetJSON();
				if (jj == NULL) {
					sprintf(error,"Can't find key `%s` as defined in`%s`", pch, j->name());
					free(key);
					return false;
				}
			}
			if (*pch == '@') pch++;
			while (pch != NULL) {
				jj = jj->Get(pch);
				if (jj == NULL) {
					sprintf(error,"Can't find key `%s` as defined in`%s`", pch, j->name());
					free(key);
					return false;
				}
				pch = strtok (NULL, ".");
				if (pch == NULL) {
					if (!compareKey(j, jj, j->name(), store, error))
						{ free(key); return false; }
				}
			}

			free(key);
		}
	}
	return true;
}

void CLI::checkExpected(const CCloudResult *res) {
	if (mExpected) {
		if (res) {
			char error[10000];
			bool passed = compareExpected(res, error);
			if (passed) {
				logger("passed...", kLOG);
				mPassed++;
			} else {
				mMissed++;
				char m[1000];
				sprintf(m, "Failed:\n%s", error);
				CHJSON *missed = new CHJSON();
				missed->Put("line", mCurLine);
				missed->Put("cmd", mScript[mCurLine-1]);
				missed->Put("error", error);
				missed->Put("res", res->GetJSON()->printFormatted());
				missed->Put("expected", mExpected->printFormatted());
				if (mMissedLog==NULL) mMissedLog = CHJSON::Array();
				mMissedLog->Add(missed);

				logger(m, kERR);
			}
		} else {
			logger("Failed: no result returned", kERR);
		}
		delete mExpected;
		mExpected = NULL;
	}
}


void CLI::abortScript(const char *error)
{
	if (error) {
		char mes[200];
		sprintf(mes, "Error at line %d : %s\n%s", mLine, mScript[mLine], error);
		logger(mes, kERR);
	}

	for (int i=0; i<mSize; i++)
		free(mScript[i]);

	mSize = 0;
	mLine = 0;
	mModeScript = false;
	mWorking = false;
	mFlowScript = 0;

	logger("End of script", kSCRIPT);

	if (error == NULL && (mPassed || mMissed || mSkipped)) {
		char m[300];

		if (mMissedLog) {
			for (int i=0; i< mMissedLog->size(); i++) {
				const CHJSON *l = mMissedLog->Get(i);
				sprintf(m, "********* %d) line %d\n	%s", i+1, l->GetInt("line"),l->GetString("error"));
				logger(m, kERR);
				logger("cmd : ", kSCRIPT);
				console("	%s",  l->GetString("cmd"));
				logger("expected : ", kSCRIPT);
				console("%s", l->GetString("expected"));
				logger("result : ", kSCRIPT);
				console("%s\n", l->GetString("res"));
			}
		}
		sprintf(m, "\n--- Tests summary ---\n\n%4d Tests", mPassed+mMissed+mSkipped);
		logger(m, kLOG);
		if (mPassed) {
			sprintf(m, "%4d Passing", mPassed);
			logger(m, kLOG);
		}
		if (mSkipped) {
			sprintf(m, "%4d Pending", mSkipped);
			logger(m, kLOG);
		}
		if (mMissed) {
			sprintf(m, "%4d Failing", mMissed);
			logger(m, kERR);
		}
		logger("\n---\n", kLOG);
	}

	mPassed = 0;
	mMissed = 0;
	mSkipped = 0;
	if (mMissedLog) delete mMissedLog;
	mMissedLog  = NULL;

	stopActivity(enNoErr);
}

const char *CLI::replaceVar(const char *line, char **res) {
	static char error[200];

	char *lp = strdup(line);

	char *var = strchr(lp, '&');
	while (var) {
		if (mVar == NULL) {
			free(lp);
			return "No var setted!";
		}
		var = strdup(var);
		char *p = strtok(var, DELIMITERS);
		//OUTPUT("var = %s", p);

		const char *data = mVar->GetString(p+1);
		if (data == NULL) {
			free(lp);
			sprintf(error, "Can't find var : %s", p);
			return error;
		}
		char *mod = str_replace(lp, p, mVar->GetString(p+1), DELIMITERS);
		free(lp);
		lp = mod;
		free(var);
		var = strchr(lp, '&');
	}

	*res = lp;

	//OUTPUT("init = %s\n", line);
	//OUTPUT("res = %s\n", lp);

	return NULL;
}

void CLI::idle() {
	CClan::Instance()->ProcessIdleTasks();
	if (mModeScript && !mWorking)
	{
		if (mLine < mSize)
		{
			char line[1000];
			strcpy(line, mScript[mLine]);

			if (*line == 0) {
				// do nothing, just keep the right line number for summary
			} else if (*line == '@') {
				if (strcmp(line, "@only")==0)
					mFlowScript = 1;
				else if (strcmp(line, "@all")==0)
					mFlowScript = 2;
				else {
					CHJSON *var =  CHJSON::parse(line+1);
					if (var) {
						if (mVar == NULL) mVar = new CHJSON();

						for (int v=0; v<var->size(); v++) {
							mVar->Put(var->Get(v)->name(), var->Get(v));
						}
						delete var;
					}
				}
			} else if (*line == '#') {
				CLI::abortScript("syntax error, get unexpected test result `#`");
				return;
			} else if (line[0] == '-' && line[1] == '-') {
				// Comment, do nothing
			} else {

				bool run = true;
				char *varline = NULL;
				const char *unknown = replaceVar(line, &varline);
				if (unknown != NULL) {
					CLI::abortScript(unknown);
					return;
				}

				logger(varline, kSCRIPT);

				int argc = 0;
				char* argv[10];
				this->tokenize(varline, &argc, argv);

				free(varline);

				if (mLine+1 < mSize) {
					strcpy(line, mScript[mLine+1]);
					if (*line == '#') {
						char *p = line+1;

						bool only  = *p == '+';
						if (only && mFlowScript==0) mFlowScript = 1; // go automatically to 'only-mode' at first '+' found.
						bool skip  = *p == '-';
						if (only || skip) p++;

						bool stand = !only && !skip;

						if (mFlowScript==0 && skip) run = false; // standard and skip

						if (mFlowScript==1 && (stand || skip)) run = false; // `only-mode` and no option

						if (mFlowScript==2) run = true; // `force-mode`

						if (run) {
							while (*p==' ') p++;

							char *np = NULL;
							const char *unknown = replaceVar(p, &np);
							if (unknown != NULL) {
								CLI::abortScript(unknown);
								return;
							}
							mExpected =  CHJSON::parse(np);
							free(np);

							mCurLine = mLine+1;
							if (mExpected == NULL) {
								logger(line, kERR);
								CLI::abortScript("Can't parse expected result");
								return;
							}
						}
						mLine++;
					} else {
						mExpected = NULL;
					}
				}

				if (run) {
					mWorking = true;
					eErrorCode ec = this->parse(argc, (const char **)argv);

					for (int c=0; c<argc; c++) free(argv[c]);

					if (ec!=enNoErr)
						CLI::abortScript(((int)ec!=-1) ? "cmd returns an error" :NULL);
				} else {
					mSkipped++;
					console("skipped...");
				}
			}

			mLine++;
		}
		else
		{
			CLI::abortScript(NULL);
		}
	}
}

int CLI::tokenize(char *line, int *argc, char *argv[])
{
	char *word = (char *)malloc(strlen(line)+1);
	char *c = line;
	char *p = word;
	int count = 0;
	bool waitClosingQuote = false;
	bool inProgress = false;
	int inJson = 0;

	for (; *c!=0; c++) // trim beginning space
		if (*c != ' ') break;

	for (; *c!=0; c++)
	{
		if (*c=='\\' && *(c+1)=='"') {
			c++;
			*p++ = *c;
			inProgress = true;

		}
		else if ((*c == '{' || *c == '[') && !waitClosingQuote)
		{
			if (!inJson)
			{
				*p=0;
				inJson++;
				p = word;
				*p++ = *c;
				inProgress = true;
			}
			else
			{
				inJson++;
				*p++ =*c;
				inProgress = true;
			}
		}
		else if ((*c == '}' || *c == ']') && !waitClosingQuote )
		{
			if (inJson)
			{
				inJson--;
				if (inJson == 0)
				{
					*p++ = *c;
					*p=0;
					argv[count++] = strdup(word);
//					OUTPUT("token2 =%s ", word);
					inProgress = false;
					*p = 0;
					p = word;
				}
				else
				{
					*p++ =*c;
				}
			}
			else
			{
				logger("Bad Json Format, found '}' without '{' ", kERR);
				return (eErrorCode)-1;
			}
		}
		else if (*c == ' ' && !waitClosingQuote && !inJson)
		{
			*p = 0;
			if (inProgress)
			{
				argv[count++] = strdup(word);
//				OUTPUT("token3 =%s ", word);
				inProgress = false;
			}
			p = word;
		}
		else if (*c == '"' && !inJson)
		{
			if (waitClosingQuote)
			{
				waitClosingQuote = false;
				*p = 0;
				if (inProgress)
				{
					argv[count++] = strdup(word);
//					OUTPUT("token4 =%s ", word);
					inProgress = false;
				}
				p = word;
			}
			else
			{
				waitClosingQuote = true;
				p=word;
				inProgress = false;
			}
		}
		else
		{
			*p++ = *c;
			inProgress = true;
		}
	}

	if (inProgress)
	{
		*p = 0;
		argv[count++] = strdup(word);
//		OUTPUT("token1 =%s ", word);
	}

	free(word);

	*argc = count;
	if (count)
	{
		for (int i=0; i<count; i++)
		{
			if (*argv[i] == '$')
			{
				int n = atoi(argv[i] + 1);
				if (n < gFavcount)
				{
					free(argv[i]);
					argv[i] = strdup(gFav[n]);
				}
			}
		}
	}

	if (waitClosingQuote)
	{
		logger("missing closing quote !", kERR);
		return (eErrorCode)-1;
	}

	if (inJson)
	{
		logger("Bad Json Format, missing '}' ", kERR);
		return (eErrorCode)-1;
	}

	return 0;
}

eErrorCode CLI::parse(int argc, const char **argv)
{
	if (argc == 0) return (eErrorCode)-1;
	if (EQL(0, "help"))
	{
		if (argc == 1)
		{
			method *p = CMD;
			for (; p->name!=NULL ; p++)
				logger(p->name);
		}
		else if (argc == 2)
		{
			method *p = CMD;
			for (; p->name!=NULL ; p++)
				if (EQL(1, p->name))
					logger(p->help);
		}
		return (eErrorCode)-1;
	}
	else if (EQL(0, ""))
		return (eErrorCode)-1;
	else if (EQL(0, "setup"))
		return this->setup(--argc, argv+1);
	else if (EQL(0, "setupappid"))
		return this->setup2(--argc, argv+1);
	else if (EQL(0, "script"))
		return this->script(--argc, argv+1);
	else if (EQL(0, "context"))
		return this->context(--argc, argv+1);
	else if (EQL(0, "cd"))
		return this->cd(--argc, argv+1);
	else if (EQL(0, "cmd"))
		return this->cmd(--argc, argv+1);
	else if (EQL(0, "set"))
		return this->set(--argc, argv+1);
	else if (myClan)
		return myClan->parse(argc, argv);

	return enSetupNotCalled;
}

const char **CLI::getcommands(const char *startwith)
{
	static const char *mCmds[100];

	method *p = CMD;
	int i;
	for (i=0; p->name!=NULL && i<300 ; p++)
	{
		if (startwith==NULL || strstr(p->name, startwith) == p->name)
			mCmds[i++] = p->name;
	}

	if (i==300) console("buffer too small for help strings")

	mCmds[i]= NULL;

	return mCmds;
}

void CLI::logger(const char *message, typelog king)
{
#ifndef __ANDROID__
	fprintf(stderr, "%s\n", message);
#endif
}

void CLI::suspend()
{
	CClan::Instance()->Suspend();
}

void CLI::resume()
{
	CClan::Instance()->Resume();
}

eErrorCode CLI::cd(int argc, const char **argv)
{
	if (argc == 0)
		return this->script(0, NULL);

	int e = chdir(argv[0]);
	if (e!=0)
		logger("Can't change directory");
	else
		this->script(0, NULL);
	return (eErrorCode)-1;
}


eErrorCode CLI::cmd(int argc, const char **argv)
{
	if (argc == 0)
	{
		for (int i=0; i< gFavcount; i++)
		{
			char txt[1000];
			sprintf(txt, "%d : %s", i, gFav[i]);
			logger(txt);
		}
	}
	else
	{
		int n = atoi(argv[0]);
		if (n<gFavcount)
			return this->execute(gFav[n]);
	}

	return (eErrorCode)-1;
}

eErrorCode CLI::set(int argc, const char **argv)
{
	if (argc == 0)
	{
		for (int i=0; i< gFavcount; i++)
		{
			char txt[1000];
			sprintf(txt, "%d : %s", i, gFav[i]);
			logger(txt);
		}
	}
	else
	{
		int i = gFavcount;
		gFav[gFavcount++] = argv[0];
		char txt[1000];
		sprintf(txt, "%d : %s", i, gFav[i]);
		logger(txt);
	}
	return (eErrorCode)-1;
}

#ifndef __ANDROID__
#ifndef WIN32

static int selector(const struct dirent *file)
{
	return strstr(file->d_name, ".cbs") != NULL;
}
#endif
#endif


eErrorCode CLI::script(int argc, const char **argv)
{
	if (argc==0)
	{
		char *path = getcwd(NULL, 0);
		logger(path);
#ifdef WIN32
	WIN32_FIND_DATA ffd;
	HANDLE  hFind;
	int	 nbFile = 0;
	TCHAR szDir[MAX_PATH];

	StringCchCopy(szDir, MAX_PATH, (LPCTSTR)argv[1]);
	StringCchCat(szDir, MAX_PATH, TEXT("\\*"));

	hFind = FindFirstFile(szDir, &ffd);
	if (INVALID_HANDLE_VALUE == hFind)
		return (eErrorCode)-1;
	do
	{
	   if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		   continue;
	   else
		   logger((char *)ffd.cFileName);
	}
	while (FindNextFile(hFind, &ffd) != 0);

#else
	#ifndef __ANDROID__
		struct dirent **namelist;

		char basePath[1000];
		this->getBasePath(basePath);
		strcat(basePath,path);

		int nbfiles = scandir (basePath, &namelist, selector, alphasort);

		if (nbfiles)
		{
			for (int i=0; i<nbfiles; i++)
				logger(namelist[i]->d_name);
			free(namelist);
		}
	#endif
#endif
		free(path);
		return (eErrorCode)-1;
	}
	else if (argc == 1)
	{
		char filename[100];
		if (strstr(argv[0], ".cbs") != NULL)
			strcpy(filename, argv[0]);
		else
			sprintf(filename, "%s.cbs", argv[0]);

		char basePath[1000];
		this->getBasePath(basePath);
		strcat(basePath,filename);

		FILE *fp = fopen(basePath, "r");
		if (fp==NULL)
		{
			logger("file not found !");
			return (eErrorCode)-1;
		}
		char str[1000];
		while(!feof(fp))
		{
			*str=0;
			if (fgets(str, 1000, fp))
			{
				size_t len = strlen(str);
				if (str[len - 1] == '\n') str[len - 1] = 0;

				mScript[mSize++] = strdup(str);
			}
		}
		fclose(fp);
		if (mSize)
		{
			mLine = 0;
			mModeScript = true;
			mWorking = false;
			mFlowScript = 0;
			return enNoErr;
		}
	}
	return (eErrorCode)-1;
}

eErrorCode CLI::setup(int argc, const char **argv)
{
	char context[1000];
	const char *arg[3] = { "cloudbuilder-key", "azerty", "sandbox"};
	strcpy(context , "context-cloudbuilder" );

	if (argc > 0) {
		if (EQL(0, "cloudbuilder")) {
			arg[0] =  "cloudbuilder-key";
			arg[1] =  "azerty";
			strcpy(context,"context-cloudbuilder");
		} else if (EQL(0, "testgame")) {
			arg[0] =  "testgame-key";
			arg[1] =  "testgame-secret";
			strcpy(context,"context-test");
		} else if (EQL(0, "demo")) {
			arg[0] =  "iNGYHsRNPv8CptZ";
			arg[1] =  "IszdXACyrnbnpHOXC7s7";
			strcpy(context,"context-demo");
		} else {
			logger("app not found. Can't setup");
			return (eErrorCode)-1;
		}
	}

	if (argc > 1) {
		arg[2] =  argv[1];
	}

	// Try to find a file that is "context-<game>-<environment>.json"
	char basePath[1000];
	char triedContextFile[1000];
	this->getBasePath(basePath);
	sprintf(triedContextFile, "%s%s-%s.json", basePath, context, arg[2]);
	if (access(triedContextFile, 0) != -1) {
 		sprintf(context, "%s-%s.json", context, arg[2]);
	} else {
		logger("Using default local context", kERR);
		strcat(context, "-local.json");
	}

	const char *ag[1] = {context};
	this->context(1, ag);

	return this->setup2(3, arg);
}

eErrorCode CLI::setup2(int argc, const char **argv)
{
	char key[40];
	char secret[80];
	char server[100];

	*server = 0;


	strcpy(key, argv[0]);
	strcpy(secret, argv[1]);

	if (argc > 2) {
		if (EQL(2, "local")) {
			strcpy(server, "http://localhost:2000");
		} else if (EQL(2, "local-parallels")) {
			strcpy(server, "http://10.211.55.2:2000");
		} else if (EQL(2, "dev")) {
			strcpy(server, "http://195.154.227.44:8000");
		} else if (EQL(2, "devlb")) {
			strcpy(server, "http://dev-api[id]:2000");
		} else if (EQL(2, "vagrant")) {
			strcpy(server, "http://localhost:8000");
		} else if (EQL(2, "vagrant-parallels")) {
			strcpy(server, "http://10.211.55.2:8000");
		} else if (EQL(2, "temp")) {
			strcpy(server, "http://192.168.1.108:2000");
		} else {
			strcpy(server, argv[2]);
		}
	}

	myClan = new MyClan(this);

	CHJSON* connection = new CHJSON;
	connection->Put("key", key);
	connection->Put("secret", secret);
	connection->Put("env", server);
	connection->Put("appVersion", "1");
	connection->Put("gamecenter", true);
	connection->Put("facebook", true);
	connection->Put("googleplus", true);
	connection->Put("disactiveRegister", false);
	connection->Put("autoresume", false);
	connection->Put("eventLoopTimeout", 590);
	connection->Put("connectTimeout", 5);
	connection->Put("httpTimeout", 0);
	connection->Put("httpVerbose", true);
	connection->Put("forceFacebookSdk", true);

	CClan::Instance()->Setup(connection, MakeResultHandler(myClan, &MyClan::SetupDone));

	delete connection;

	return enNoErr;

}

eErrorCode CLI::context(int argc, const char **argv) {

	if (argc == 0) {
		logger(mVar->printFormatted(), kLOG);
		return (eErrorCode)-1;
	}
	
	if (argc!=1) return (eErrorCode)-1;

	const char *filename = argv[0];

	char basePath[1000];
	this->getBasePath(basePath);
	strcat(basePath,filename);

	FILE *f = fopen(basePath, "rb");
	if (f==NULL)
	{
		logger("context file not found !",kERR);
		logger(basePath, kERR);
		return (eErrorCode)-1;
	}

	fseek(f, 0, SEEK_END);
	long fsize = ftell(f);
	fseek(f, 0, SEEK_SET);

	char *content = (char *)malloc(fsize + 1);
	fread(content, fsize, 1, f);
	fclose(f);

	content[fsize] = 0;

	if (mVar) delete mVar;
	mVar = CHJSON::parse(content);

	free(content);

	if (mVar == NULL) {
		logger("Can't parse the context file !",kERR);
		return (eErrorCode)-1;
	}

	logger(mVar->printFormatted(), kLOG);

	return (eErrorCode)-1;

}

void CLI::HandleURL(const CHJSON *j) {

	CClan::Instance()->HandleURL(j, MakeResultHandler(myClan, &MyClan::RestoreSessionDone));

}

void CLI::getFavorites(const char** &favoriteList, int &count) {
	favoriteList = gFav;
	count = gFavcount;
}
